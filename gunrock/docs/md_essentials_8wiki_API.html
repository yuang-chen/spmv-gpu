<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Essentials: API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Essentials
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   <div id="projectbrief">High-Performance C++ GPU Graph Analytics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_essentials_8wiki_API.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document is intended as an overview of essentials API, if you're interested in the complete API specification, please refer to the Doxygen generated documentation found at <a href="https://gunrock.github.io/essentials/">https://gunrock.github.io/essentials/</a>. You can also check out the tutorial on <a href="https://github.com/gunrock/essentials/wiki/How-to-write-a-new-graph-algorithm">"How to write a new graph algorithm"</a> for more information.</p>
<h2>Graph</h2>
<p>Graph APIs are very fundamental to essentials, we will go through the process from construction to usage. First, it is important to identify that a graph can be constructed with multiple views. A graph view is how a graph in essentials is stored and is "communicated" with. As of writing this document, we currently support three different views: compressed sparse row (CSR), compressed sparse column (CSC), and coordinate format (COO). You can read more about these sparse formats on the web. In the following example, we will use CSR as our graph view, but just know that a graph can be constructed with more than one view as well (we will show an example of that later).</p>
<p>### Constructing the graph </p><div class="fragment"><div class="line"><span class="comment">// Define vertex, edge, weight types.</span></div><div class="line"><span class="keyword">using</span> vertex_t = int;</div><div class="line"><span class="keyword">using</span> edge_t = int;</div><div class="line"><span class="keyword">using</span> weight_t = float;</div><div class="line"></div><div class="line"><span class="comment">// Define CSR view type.</span></div><div class="line"><span class="keyword">using</span> csr_v_t = graph::graph_csr_t&lt;vertex_t, edge_t, weight_t&gt;</div><div class="line"></div><div class="line"><span class="comment">// Define the graph type.</span></div><div class="line"><span class="keyword">using</span> my_graph_t = graph::graph_t&lt;</div><div class="line">    memory::memory_space_t::device, <span class="comment">// construct graph on device.</span></div><div class="line">    vertex_t, edge_t, weight_t, csr_v_t&gt;;</div><div class="line"></div><div class="line">my_graph_t G;</div></div><!-- fragment --><p> We now have a graph <code>G</code>, defined using <code>my_graph_t</code> with a <code>csr_v_t</code> as the view. Once a graph is created, to actually use it, we must set the underlying CSR data.</p>
<div class="fragment"><div class="line"><span class="comment">// Where the parameters for the csr matrix are passed in.</span></div><div class="line">G.template set&lt;csr_v_t&gt;(num_rows, num_nonzeros, row_offsets, column_indices, values);</div></div><!-- fragment --><h4>Construct using a graph builder</h4>
<p>A simpler way to build the graph is to use the <code>build::</code> helper functions, where you pass in the compressed sparse row data and it returns the generated graph. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> G = graph::build::from_csr&lt;memory_space_t::device, graph::view_t::csr&gt;(</div><div class="line">    csr.number_of_rows,               <span class="comment">// rows</span></div><div class="line">    csr.number_of_columns,            <span class="comment">// columns</span></div><div class="line">    csr.number_of_nonzeros,           <span class="comment">// nonzeros</span></div><div class="line">    csr.row_offsets.data().get(),     <span class="comment">// row_offsets</span></div><div class="line">    csr.column_indices.data().get(),  <span class="comment">// column_indices</span></div><div class="line">    csr.nonzero_values.data().get()   <span class="comment">// values</span></div><div class="line">);  <span class="comment">// supports row_indices and column_offsets (default = nullptr)</span></div></div><!-- fragment --><h3>Using the graph</h3>
<p>Graph class has many useful members, which you can access in the <code>__device__</code> code. Even if the graph is declared on <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/memory.hxx#L23-L34"><code>memory::memory_space_t::device</code></a> constants members (like the number of vertices or edges within a graph) are also available in the <code>__host__</code> code. To see all the available APIs, see the <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/graph/graph.hxx">implementation</a>.</p>
<p>In your <code>__host__</code> code, you can do the following: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> num_vertices = G.get_number_of_vertices();</div><div class="line"><span class="keyword">auto</span> num_edges = G.get_number_of_edges();</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\tNumber of Graph Representations = &quot;</span></div><div class="line">          &lt;&lt; G.number_of_graph_representations() &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;\tContains CSR Representation? &quot;</span> &lt;&lt; std::boolalpha</div><div class="line">          &lt;&lt; G.template contains_representation&lt;csr_view_t&gt;() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Or in your <code>__device__</code> code, you can do the following: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> source = 2;</div><div class="line"><span class="keyword">auto</span> edge = 1;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> num_vertices = G.get_number_of_vertices();</div><div class="line"><span class="keyword">auto</span> num_edges = G.get_number_of_edges();</div><div class="line"><span class="keyword">auto</span> num_neighbors = G.get_number_of_neighbors(source);</div><div class="line"><span class="keyword">auto</span> source_vertex = G.get_source_vertex(edge);</div><div class="line"><span class="keyword">auto</span> destination_vertex = G.get_destination_vertex(edge);</div><div class="line"><span class="keyword">auto</span> edge_weight = G.get_edge_weight(edge);</div></div><!-- fragment --><h3>Operations on the graph</h3>
<p>The <code>graph::</code> namespace provides helpful functions. </p><div class="fragment"><div class="line">thrust::device_vector&lt;vertex_t&gt; histogram(<span class="keyword">sizeof</span>(vertex_t) * 8 + 1);</div><div class="line">graph::build_degree_histogram(G, histogram.data().get());</div></div><!-- fragment --><p>See a more complete example of using graph APIs in <a href="https://github.com/gunrock/essentials/blob/master/unittests/graph/test_graph.cu">test_graph.cu</a> unit test.</p>
<h2>Operator</h2>
<p><a href="https://github.com/gunrock/essentials/wiki/Programming-Model">As described briefly</a>, operators in Essentials are parallel primitives that perform operations on frontiers or graphs. We offer a range of operators, which are all found under <code>include/gunrock/framework/operators/</code>. All of these operators, their <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/operators/configs.hxx">configurations</a>, and related APIs are accessible using the following include and namespace:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8hxx.html">gunrock/framework/operators/operators.hxx</a>&gt;</span></div><div class="line"><span class="keyword">using namespace </span>operators;</div></div><!-- fragment --><h3>Some example APIs... (using <code>advance</code>)</h3>
<p><a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/operators/advance/advance.hxx">Advance</a> is a traversal operator, which takes in an input frontier of vertices or edges, and generates an output frontier containing all of the neighboring vertices or edges. Advance can be called using a <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/operators/advance/advance.hxx#L129-L198">beginner</a> API, which simplifies the interface, or an <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/operators/advance/advance.hxx#L29-L99">expert</a> API allowing more control over the input and output parameters.</p>
<p>#### A simple call to advance. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sample_lambda = [=] __host__ __device__(</div><div class="line">                             vertex_t <span class="keyword">const</span>&amp; source,    <span class="comment">// ... source</span></div><div class="line">                             vertex_t <span class="keyword">const</span>&amp; neighbor,  <span class="comment">// neighbor</span></div><div class="line">                             edge_t <span class="keyword">const</span>&amp; edge,        <span class="comment">// edge</span></div><div class="line">                             weight_t <span class="keyword">const</span>&amp; weight     <span class="comment">// weight (tuple).</span></div><div class="line">                             ) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">    <span class="comment">// Do something on the source, neighbor, edge, weight tuple.</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Execute advance operator on the provided lambda.</span></div><div class="line">operators::advance::execute(G, E, sample_lambda, context);</div></div><!-- fragment --><p>#### An expert call to advance. </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sample_lambda = [=] __host__ __device__(</div><div class="line">                             vertex_t <span class="keyword">const</span>&amp; source,    <span class="comment">// ... source</span></div><div class="line">                             vertex_t <span class="keyword">const</span>&amp; neighbor,  <span class="comment">// neighbor</span></div><div class="line">                             edge_t <span class="keyword">const</span>&amp; edge,        <span class="comment">// edge</span></div><div class="line">                             weight_t <span class="keyword">const</span>&amp; weight     <span class="comment">// weight (tuple).</span></div><div class="line">                             ) -&gt; <span class="keywordtype">bool</span> {</div><div class="line">    <span class="comment">// Do something on the source, neighbor, edge, weight tuple.</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Execute advance operator on the provided lambda.</span></div><div class="line">operators::advance::execute&lt;operators::load_balance_t::block_mapped,</div><div class="line">                            operators::advance_direction_t::forward,</div><div class="line">                            operators::advance_io_type_t::graph,</div><div class="line">                            operators::advance_io_type_t::none&gt;(</div><div class="line">    G, E, sample_lambda, context);</div></div><!-- fragment --><h3>Some example APIs... (using <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/operators/batch/batch.hxx#L25-L29"><code>batch</code></a>)</h3>
<div class="fragment"><div class="line"><span class="keyword">auto</span> f = [&amp;](std::size_t job_idx) -&gt; <span class="keywordtype">float</span> {</div><div class="line">    <span class="keywordflow">return</span> 0.0f; <span class="comment">// ... return elapsed time of one job.</span></div><div class="line">  };</div><div class="line"></div><div class="line">std::size_t n_jobs = 10;</div><div class="line">std::vector&lt;float&gt; total_elapsed(1); <span class="comment">// to calculate total elapsed time of n_jobs.</span></div><div class="line">operators::batch::execute(f, n_jobs, total_elapsed.data());</div></div><!-- fragment --><h2>Frontier</h2>
<p>Frontier is a data structure that represents the active working set in a graph algorithm. A frontier could represent a subset of a graph (such as a single source node from which an algorithm begins processing) or an entire graph. Like the <code>graph_t</code> representation, our frontier abstraction allows the frontier to be viewed as many different underlying data structures (such as a vector/sparse-frontier, boolmap, bitmap, etc.) Although not all of these representations might be implemented yet, the abstraction allows for easy integration with simple C++ inheritance.</p>
<h3>Instantiating a frontier</h3>
<p>Created on the host, but a frontier can be passed into a kernel (<code>__global__</code>) function and many of its APIs prefixed with <code>__device__</code> can be used within a kernel. </p><div class="fragment"><div class="line"><span class="keyword">using</span> vertex_t = int;</div><div class="line"><span class="keyword">using</span> edge_t = int;</div><div class="line"></div><div class="line">frontier::frontier_t&lt;</div><div class="line">  vertex_t,                                    <span class="comment">// vertex type</span></div><div class="line">  edge_t,                                      <span class="comment">// edge type</span></div><div class="line">  frontier::frontier_kind_t::vertex_frontier,  <span class="comment">// type of the frontier (vertex or edge frontier)</span></div><div class="line">  frontier::frontier_view_t::vector            <span class="comment">// underlying frontier data structure</span></div><div class="line">&gt; my_frontier;</div></div><!-- fragment --><h3>Using a frontier</h3>
<p>APIs are available in <a href="https://github.com/gunrock/essentials/tree/master/include/gunrock/framework/frontier"><code>gunrock/framework/frontier</code></a>. We'll go through some common use cases: </p><div class="fragment"><div class="line"><span class="comment">// get the number of elements in a frontier, for some underlying</span></div><div class="line"><span class="comment">// views, this may require a stream.</span></div><div class="line">std::size_t n = my_frontier.get_number_of_elements();</div><div class="line"></div><div class="line"><span class="comment">// check if the frontier is empty.</span></div><div class="line"><span class="keywordtype">bool</span> empty = my_frontier.is_empty();</div></div><!-- fragment --><p>Inside a CUDA kernel or a <code>__device__</code> lambda function, one might want to use the frontier to set or get an element: </p><div class="fragment"><div class="line">my_frontier.get_element_at(0); <span class="comment">// get the element at 0th position</span></div><div class="line">my_frontier.set_element_at(my_vertex, 0); <span class="comment">// set 0th position to my_vertex</span></div></div><!-- fragment --><h3>Resizing a frontier</h3>
<p>When represented as a vector frontier, <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/frontier/vector_frontier.hxx#L212">resizing</a> a frontier could be a challenging task. For example, when advancing an input frontier, the output frontier may become really large, and you'd want it to be sized appropriately to handle all the neighboring vertices of the input frontier. However, resizing requires reallocating memory and moving the data over and is often an expensive task. Therefore, in gunrock, we utilize a <code>frontier_resizing_factor</code> property, which simply means when resizing to a certain size, multiply that size with the <code>frontier_resizing_factor</code> and allocate more memory than needed: <code>size * frontier_resizing_factor</code> (real capacity allocated). This is done to avoid reallocation as much as possible.</p>
<h2>Problem and Enactor</h2>
<p><a href="https://github.com/gunrock/essentials/wiki/How-to-write-a-new-graph-algorithm">How to write a new graph algorithm</a> provides a good introduction to the useful APIs for <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/problem.hxx"><code>problem_t</code></a> and <a href="https://github.com/gunrock/essentials/blob/master/include/gunrock/framework/enactor.hxx"><code>enactor_t</code></a>. The simplest explanation of the two is: <code>problem_t</code> is used to set up all of your data and <code>enactor_t</code> is used to implement your algorithm (and use the data set in <code>problem_t</code>). Two things to clarify: 1) the reason why these structs exist is to provide a clean way to hide a lot of gunrock's execution details, and maybe in the future add required multi-GPUs pathways without needing to change the algorithm at the user level, and 2) from an application/algorithm's perspective, the user simply needs to inherit gunrock's <code>enactor_t</code> and <code>problem_t</code> and start taking advantage of it. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
